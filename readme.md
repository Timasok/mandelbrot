# Задачи
Освоить методы оптимизации с помощью:
1. SIMD-инструкций
2. Флагов компиляции -O

# Алгоритм Мандельброта

Множество мандельброта - фрактал, который можно обсчитать по простому алгоритму. 
Алгоритм следующий:

``Z(n+1)^2 = Z(n)^2+Z0``, где ``Z0`` - координата начальной точки на комплексной плоскости.
Координаты ```Z(n+1)``` вычисляются по данному правилу:

```X(n+1) = X(n)^2 - Y(n)^2 + X0```
```Y(n+1) = 2*X(n)*Y(n) + Y0```

Вычисления продолжаются до тех пор, пока расстояние от ```Z(n)``` до начала координат ```(0, 0)``` не превысит ```R_max = 10``` или пока ```n``` не превысит ```N_max = 256```. 

Подробнее про этот алгоритм можно прочитать тут: 
https://webdesign.ru.net/article/pravila-oformleniya-fayla-readmemd-na-github.html

Вот пример изображения, выдаваемого нашей программой:
![Mandelbrot](img/Mandelbrot_set.png)

Уже на этом этапе мы можем грубо оценить время рисования изображения. Оно будет пропорционально количеству пикселей.

```t ~ window->width * window->height```

# Методы оптимизации

Мы использовали набор функций intel SSE intrinsics. Переменные ```__m128``` и ```__m128i``` из набора инструкций позволяют выполнять операции с 4-мя пикселями одновременно.

Подробнее про SIMD можете почитать тут:
http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html

# Способы измерения времени

Напрямую мы измеряли *iteration time* с помощью ```sf::Clock```. А затем вычисляли *FPS* по этой формуле: *FPS* = 1/*iteration time*. 

```iteration time = number_of_pixels*(calculation_time + drawing_time)```

В качестве эксперимента мы запускали программу в следующих режимах:
1. Без отрисовки.
2. С отрисовкой.

<!-- Т.к. одного вычисления одного цвета это ```calculation_time```, а измерять мы можем без замедления самих вычислений только ```iteration time```. Поэтому для снижения погрешности можно увеличить вес вычислений в ```k = 1000``` раз. Тогда 
```iteration time/k = number_of_pixels*(calculation_time*k + drawing_time) ≈ number_of_pixels*calculation_time``` -->

В таблице снизу приведены значения *FPS* при разных настройках запуска. Также для каждого посчитан коэффицент ускорения относительно первой ячейки этой строки, т.е запуска без флагов. 

# Результаты измерений

|   Режимы запуска  | Без флагов  |     -O2     |     -O3     |     -Ofast    |
| :---------------: | :----------:| :---------: | :---------: | :----------:  |
|    1 + no_sse     |  **6.15** (1x) | 11.1 (1.8x) | 11.2 (1.8x) |  11.6  (1.9x) |
|    2 + no_sse     |   1.43 (1x) | 1.81 (1.3x) | 1.77 (1.2x) |  1.65  (1.2x) |
|    1 + sse        |   8.62 (1x) | 39.6 (4,6x) | 40.3 (4.7x) | **42.6** (4.9x) |

Сравнивая первые два ряда таблицы, мы можем заключить, что:
2-й режим плохо ускоряется даже компиляторными флагами оптимизации. 
Время рисования примерно в **5** раз больше времени расчётов. 

Отсюда заключаем, что запуск программы во 2-м режиме бессмысленный. И поэтому ускорение с помощью SSE во 2-м режиме не будет заметно.

Максимальный коэффициент ускорения в каждой строке характеризует ускорение, которого можно достичь с помощью -O флагов.
+ K_o = **1.9**
+ K_o = **1.3**
+ K_o = **4.9**

Выделенные значения позволяют увидеть ускорение, достигнутое двумя оптимизациями одновременно.
+ K_sse+o = 42.6/6.15 = **6.9**

# Выводы

Основная задача проекта была выполнена. Мы научились снижать систематическую погрешность измерения времени работы алгоритма, а также оптимизировать его с помощью SIMD-инструкций. Эксперимент показал возможность ускорения в 7 раз.
